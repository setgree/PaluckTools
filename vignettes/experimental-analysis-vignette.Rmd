---
title: "Experimental analysis and table formatting"
output:
  rmarkdown::html_vignette:
    fig_width: 7
    fig_height: 7
vignette: >
  %\VignetteIndexEntry{4. Experimental analysis and table formatting}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette demonstrates tools for analyzing experimental data and creating publication-ready tables. While the previous vignettes focused on meta-analysis, this one covers the experimental analysis workflow.

We'll cover:

1. `tidy_lm` for running multiple regression specifications efficiently
2. `robust_se` for cluster-robust standard errors
3. Table formatting utilities for LaTeX output

For demonstration purposes, we'll use the built-in `sv_data` and `contact_data` from our meta-analyses, treating them as if they were experimental datasets.

## 1 Running multiple regressions with `tidy_lm`

When analyzing experimental data, you often need to run many regression specifications: different dependent variables, different sets of controls, different subsamples. The `tidy_lm` function streamlines this process.

### 1.1 Basic usage

Let's start with a simple example using `sv_data`:

```{r basic_tidy_lm}
library(PaluckTools)
library(dplyr)

# Run a simple regression of d on study_design
results <- tidy_lm(
  data = sv_data,
  dv = "d",
  terms = "study_design"
)

# View the structure
head(results)
```

The output is a tidy data frame where each row represents one regression model. The `lm` column contains the actual model object.

### 1.2 Multiple dependent variables

A common pattern is testing the same predictors on multiple outcomes:

```{r multiple_dvs}
# Test study_design on both d and var_d
results_multi_dv <- tidy_lm(
  data = sv_data,
  dv = c("d", "var_d"),
  terms = "study_design",
  treatment = "study_design"
)

# The treatment parameter extracts coefficients for easy viewing
head(results_multi_dv |> select(dv, study_design_coef, study_design_p))
```

### 1.3 Different regression styles

`tidy_lm` supports different ways of combining your predictors:

```{r regression_styles}
# "default": all terms together
default_style <- tidy_lm(
  data = sv_data,
  dv = "d",
  terms = c("study_design", "scale_type"),
  style = "default"
)

# "bivariate": each term separately
bivariate_style <- tidy_lm(
  data = sv_data,
  dv = "d",
  terms = c("study_design", "scale_type"),
  style = "bivariate"
)

# "incremental": start with first term, progressively add more
incremental_style <- tidy_lm(
  data = sv_data,
  dv = "d",
  terms = c("study_design", "scale_type"),
  style = "incremental"
)

cat("Default style creates", nrow(default_style), "model(s)\n")
cat("Bivariate style creates", nrow(bivariate_style), "model(s)\n")
cat("Incremental style creates", nrow(incremental_style), "model(s)\n")
```

### 1.4 Real-world example: Effect moderators

A typical analysis might test whether effects differ by study characteristics:

```{r moderator_analysis, eval=FALSE}
# Do contact effects vary by target of prejudice?
contact_models <- tidy_lm(
  data = contact_data,
  dv = "d",
  terms = c("target_spelled_out", "pop_spelled_out"),
  treatment = c("target_spelled_out", "pop_spelled_out"),
  style = "incremental"
)

# Extract key coefficients
contact_models |>
  select(model_number, starts_with("target"), starts_with("pop")) |>
  filter(!is.na(target_spelled_out_p))
```

## 2 Cluster-robust standard errors

### 2.1 Using `robust_se`

When your data has clustering (e.g., multiple observations per study or school), you need cluster-robust standard errors:

```{r robust_se, eval=FALSE}
# Basic regression
model <- lm(d ~ study_design + scale_type, data = sv_data)

# Get cluster-robust SEs (clustering by unique_study_id)
robust_results <- robust_se(model, cluster = sv_data$unique_study_id)

# robust_results is a list with:
# [[1]]: variance-covariance matrix
# [[2]]: coefficient test with robust SEs

robust_results[[2]]
```

### 2.2 Incorporating clusters into `tidy_lm`

You can also specify clusters directly in `tidy_lm`:

```{r tidy_lm_clusters, eval=FALSE}
clustered_models <- tidy_lm(
  data = sv_data,
  dv = "d",
  terms = c("study_design", "scale_type"),
  treatment = "study_design",
  clusters = unique_study_id
)

# The clusters are handled automatically in the model fitting
```

## 3 Preparing tables for publication

### 3.1 Using `star_ready` with stargazer

The `star_ready` function prepares `tidy_lm` output for use with the `stargazer` package:

```{r star_ready_demo, eval=FALSE}
# First, run your models
models <- tidy_lm(
  data = sv_data,
  dv = "d",
  terms = c("study_design", "scale_type"),
  style = "incremental"
)

# Prepare for stargazer
ready_for_table <- star_ready(models, data = sv_data)

# Now use with stargazer (not run here to avoid LaTeX output)
# library(stargazer)
# stargazer(ready_for_table, type = "latex")
```

### 3.2 Table formatting utilities

The package includes 14 utility functions for formatting LaTeX tables. Here are the most useful:

#### add_parentheses and two_digits

```{r table_utilities}
# Format numbers consistently
values <- c(0.1543, 2.567, 10.2)
two_digits(values)

# Add parentheses (useful for standard errors)
add_parentheses(two_digits(values))
```

#### print_table

A cleaner way to display LaTeX tables in R:

```{r print_table, eval=FALSE}
# Instead of manually cat-ing table output
library(knitr)
my_table <- capture.output(kable(head(sv_data), format = "latex"))

# Use print_table for nicer display
print_table(my_table)
```

#### stargazer_pvalues

Change how p-values appear in stargazer tables:

```{r stargazer_pvalues, eval=FALSE}
# Capture stargazer output
model <- lm(d ~ study_design, data = sv_data)
table_output <- capture.output(
  stargazer(model, report = "csp", type = "latex")
)

# Change "p = 0.05" format to brackets
table_with_brackets <- stargazer_pvalues(table_output, "brackets")
print_table(table_with_brackets)
```

### 3.3 Additional formatting functions

Other useful functions include:

- `add_endnote()`: Add custom footnotes to tables
- `add_top_row()` / `add_bottom_row()`: Add rows to data frames
- `table_label()`: Add LaTeX labels for cross-referencing
- `table_numbers()`: Customize table numbering (e.g., Table 2a, 2b)
- `word_italicize()`: Italicize specific words in LaTeX tables

See `?table_prep` for full documentation of all formatting functions.

## 4 Putting it all together

Here's a complete workflow from analysis to publication-ready table:

```{r complete_workflow, eval=FALSE}
# 1. Run your regressions
models <- tidy_lm(
  data = sv_data |> filter(!is.na(study_design)),
  dv = c("d", "var_d"),
  terms = c("study_design", "scale_type", "delay"),
  treatment = c("study_design", "scale_type"),
  style = "incremental",
  clusters = unique_study_id
)

# 2. Prepare for stargazer
table_ready <- star_ready(models, data = sv_data)

# 3. Create table
library(stargazer)
raw_table <- capture.output(
  stargazer(
    table_ready,
    type = "latex",
    title = "Effect of interventions by study design",
    dep.var.labels = c("Effect size (d)", "Variance"),
    notes = "Placeholder note text"
  )
)

# 4. Format the table
formatted_table <- raw_table |>
  add_endnote(
    note = "Standard errors clustered by study. All models control for scale type and delay.",
    size_in_inches = 6,
    rm.stargazer.stars = TRUE
  ) |>
  table_label(caption = "main_results")

# 5. Print for LaTeX document
print_table(formatted_table)
```

## 5 Key takeaways

**For running regressions:**
- Use `tidy_lm` when you need to run many specifications
- Specify `treatment` to extract coefficients you care about
- Use `clusters` for cluster-robust standard errors
- Choose `style` based on your needs (bivariate, incremental, default)

**For creating tables:**
- `star_ready` bridges `tidy_lm` output to `stargazer`
- Table formatting functions help polish LaTeX output
- `print_table` makes viewing LaTeX tables easier
- Combine functions with pipes for clean workflows

**Best practices:**
- Always cluster standard errors when you have grouped data
- Use consistent number formatting (`two_digits`) across tables
- Add descriptive notes and labels for reproducibility
- Test table formatting in your LaTeX document early

For more examples, see the function documentation with `?tidy_lm`, `?star_ready`, or `?table_prep`.
